-
  id: 012
  title: "Accelerated TDD: For More Productive C++"
  description: "<p>We all know that writing tests for our code is “what we should do”, and maybe we’re even doing that already. But it feels like extra busy-work that slows us down – and they hardly ever catch any bugs anyway, right? …</p>
  <p>Maybe we’ve even tried TDD, and felt that it was just adding even more ceremony to the problem with no real advantages.</p>
  <p>But the advantages are definitely there. When done properly and appropriately a TDD approach can greatly accelerate your ability to produce code that solves the right problems faster - and more correctly! We just need a good grounding in what TDD _actually_ is (and isn’t) and how to do it properly – especially in the context of C++, which brings it’s own idiosyncrasies and bottlenecks to the matter.</p>  
  <p>That’s what this workshop aims to be. Whether you’ve never written a test before, or you’ve had some mileage with TDD already, be prepared to ratchet up your productivity by thinking about things in new ways and gaining more approaches to breaking down problems in sustainable ways.</p>"
  subtype: workshop
  speakers: [10]
  language: en
-
  id: 013
  title: "Understanding Object Lifetime"
  description: "<p>C++ has something very few other languages have: a well defined object life cycle. Understanding this key aspect of C++ is critical to writing clean, maintainable, and efficient C++.</p>
  <p>Anyone who is a beginner or intermediate C++ programmer will gain a much better understanding of how the compiler treats objects and what behavior we can rely on. We will study and discuss many examples as a class in a group discussion.</p>
  <p>We will cover:</p>
  <ul>
    <li>Understanding RAII</li>
    <li>What does the standard say?</li>
    <li>Member variable lifecycle</li>
    <li>How and why to limit variable scope</li>
    <li>The as-if rule</li>
    <li>std::move and std::forward</li>
    <li>Passing values</li>
    <li>Returning values</li>
    <li>Lifecycle of lambda captures</li>
    <li>How the C++ memory model and object lifetime relate</li>
    <li>Gotchas</li>
    <li>A note about runtime polymorphism</li>
    <li>What changes in C++17</li>
  </ul>"
  subtype: workshop
  speakers: [11]
  language: en
- id: 014
  title: "C++ Best Practices Revisited: Better Code, Better Work-Life Balance"
  description: "<p>In this training we would deal with the following:</p>
  <ul>
    <li>What makes C++ code better or worse: between personal taste and plain bad coding and design</li>
    <li>How to write better code</li>
    <li>When and how to perform refactoring</li>
    <li>How to perform effective code reviews, what to look for and how</li>
  </ul>
  <p>The training would be focused on C++ in general, but would include a look into the features of C++11 to C++17 and the proper usage of those. It will also include some actual practice on real C++ code. Attendees would gain better view on writing maintainable long living C++ code.</p>
  <p>The training would cover both the nitty gritty bits and bytes of the language and the bigger design issues like how to identify that your if-else should become a state-machine, actor model vs. data model and concurrency design.</p>" 
  subtype: workshop
  speakers: [12]
  language: he
-
  id: 015
  title: "Embedded Systems Programming in C++"
  description: "<p>This workshop explains how to use Modern C++ to write safe, efficient, and maintainable embedded programs. Step by step, it shows how to leverage C++ language features to write abstractions that represent and manipulate hardware in a bare metal environment. It also explains how to make these abstractions easy to use and hard to misuse.</p>
<p>Using concrete programming examples, this workshop explains how to use C++ features such as classes, overloading, and user-defined type conversions to hide messy hardware details behind cleaner interfaces. It shows how to use templates and inheritance to capture commonality among devices and promote code reuse without sacrificing performance. It illustrates practical uses for modern features such as constexpr, static_assert, and type_traits to make embedded code safer, faster, smaller, and more maintainable. It demonstrates programming styles and idioms that turn potential run-time errors into compile-time errors, and turn run-time computations into compile-time computations.</p>
<p>Participants should have experience programming in C++, or experience in C along with a basic knowledge of the C++ constructs such as classes, access control, and constructors.</p>
<p>This workshop includes programming exercises. The exercises run on a simulator provided by the instructor. For the exercises, students will need a computer with a development environment that can edit, compile, link, and execute command-line applications written in C++14.</p>"
  subtype: workshop
  speakers: [13]
  language: en
-
  id: 016
  title: "Workshop: A Practical Introduction to Conan C and C++ Package Manager"
  description: "<p>This class is a full hands-on introductory course to how to use Conan, the open source C and C++ package manager. In this course you will learn how to consume existing packages in your applications and how to create packages for your own libraries. Integrations with different build systems, development of packages, versioning, dependencies conflicts, ABI compatibility and binaries management: All these concepts will be approached and learnt in real working exercises, installing, creating, cross-building, uploading and downloading packages.</p>
<p>Outline:</p>
<ul>
  <li>Introduction</li>
  <li>Using existing packages in your applications</li>
  <li>Using different build systems: Conan generators and build helpers</li>
  <li>Searching and displaying information about packages and the dependency graph</li>
  <li>Creating packages for C++ libraries</li>
  <li>The binary model: how to create and maintain packages for different OS, compilers, architectures… Using profiles</li>
  <li>Cross-compiling packages</li>
  <li>Conan decentralized architecture: uploading and downloading packages to remote servers. Using Artifactory CE server and Bintray</li>
  <li>Using Conan packages to wrap tools like CMake, compilers or testing frameworks, with build-requires</li>
</ul>"
  subtype: workshop
  speakers: [14]
  language: en
-
  id: 003
  title: "Keynote: The Best Parts of C++"
  place: "Main Hall"
  description: "C++ is a big language, and it gets bigger every year. Is C++ it *too* big? Do we just continue to make the language harder to learn? Or, perhaps, do these language additions actually make the language better and easier to use? We will take a pragmatic look at the changes brought to C++ over the years and what impact they have had on how we write code."
  speakers: [11]
  subtype: keynote
  language: en
-
  id: 004
  title: "Keynote 2"
  place: "Main Hall"
  description: "Stay tuned for the second keynote speaker announcement!"
-
  id: 005
  title: "Technical Sessions"
  description: "A lot of great C++ content!"
-
  id: 006
  title: "More activities"
  description: "In construction"
  service: true
-
  id: 021
  title: "C++ Programming for the Heap-Deprived: Solving common problems without dynamic memory allocation"
  description: "Avoiding dynamic memory (heap) allocations is a common practice in embedded development. In this talk we will discuss common problems and solutions, why to avoid heap allocation in the first place in some cases, and what does the C++ standard have to say about this?"
  subtype: talk
  speakers: [21]
  language: en
-
  id: 022
  title: "179 range algorithms in less than an hour"
  description: "<p>STL algorithms are something every C++ programmer should know. As range algorithms are expected to arrive to C++ 20, there are even more useful tools that we should at least be aware of, if not use daily.</p> 
                <p>In this talk we will cover what ranges add to C++20 standard library, as well as go over all the different views and actions available in the range-v3 library which can be used today.</p>
                <p>We will see examples of combining algorithms, views and actions effectively to write more expressive and sometimes even more performant code.</p>
                <p>This talk is inspired by Jonathan Boccara’s talk '105 algorithms in less than an hour'.</p>"  
  subtype: talk
  speakers: [22]
  language: en
-
  id: 023
  title: "Coroutines - the future of future (and more)"
  description: "<p>Writing asynchronous code is never easy. The programmer must consider things like race conditions and dead-locks, it's harder to reason about the code and all kinds of pitfalls come up. On the other hand, async operations become more and more common with the raise of multicore computing, with more network communication used and with some of the architectures we develop to (e.g. OSes that supply only async API for I/O operations).</p>
                <p>Coroutines are the newest (planned) addition to the C++ language to ease the development of such code and make it much simpler, closer to traditional, synchronous code and easier to reason about.</p>
                <p>In this talk we'll learn what kind of problems coroutines come to solve, what the solution looks like from the user perspective and a glance towards the much wider solution space that coroutines open for us with various usages already exist.</p>
                <p>This is an 'into to coroutines' kind of presentation, definitely not delving into the 'dirty details' of how things are implemented in the low level.</p>"
  subtype: talk
  speakers: [23]
  language: en
-
  id: 024
  title: "Clang Concepts"
  description: "Concepts are one of the biggest new features coming in C++20, set to revolutionize the way we write generic code. A year ago I volunteered to implement Concepts in the Clang Compiler, and am now nearing completion of the feature. I will tell the story of how I got around to doing this, while demonstrating what it is like to take on such a daunting codebase as a compiler for the first time, and some lessons learned. A brief introduction to the feature itself will also be provided."
  subtype: talk
  speakers: [24]
  language: en
-
  id: 025
  title: "Behind Enemy Lines - Reverse Engineering C++ in Modern Ages"
  description: "<p>What do C++ programs really look like? When developers think about hierarchy and virtual calls they see it as design patterns and code but reverse engineers look at it from a different angle, they think about Assembly puzzles.</p>
                <p>C++ is known as a tangled language, templates, lambdas and pointers. All of these features create a jungle of objects intended to make life easier for the programmer. But once the program is compiled, the target program is no longer what it once seemed.</p>
                <p>Reversing C++ programs is tedious, demanding, and requires rebuilding inheritance, identifying templates and tainting program flow in order to combat the ties of function overloading and class utilization.</p>
                <p>C++ Binaries are a world of mysteries. In my presentation I am going to show how C++ binaries looks like after compilation and how reverse engineers see C++ binaries and understand their logic.</p>"
  subtype: talk
  speakers: [25]
  language: en
-
  id: 026
  title: "Virtual Tables OR The Overhead Of Magic"
  description: "<p>C++ provides a lot of wonderful tools, but at its heart stands the inheritance mechanism and the engine that drives it - the Virtual Table.</p>
                <p>We will talk about the virtual table - when and how it works, and of course, when it does NOT work. We will review the problems that may arise from using it wrongly.</p>
                <p>And finally, we will try to provide tools for estimating the performance cost and possible solutions to minimize it.</p>"
  subtype: talk
  speakers: [26]
  language: en
-
  id: 027
  title: "C/C++ Memory Model"
  description: "<p>Memory Model is probably the single most important change introduced in C++11.</p>
                <p>In this talk we will discuss what is a memory model, and more importantly, why we should care. Spoiler alert: The answer in one line: it will help us to write faster more correct code for multi threads and even single thread. Along the way, we will delve into exciting side topics such as Data Oriented Design, Cache Oblivious Algorithms, False Sharing and more.</p>"
  subtype: talk
  speakers: [27]
  language: en
-
  id: 028
  title: "High Frequency Trading and Ultra Low Latency development techniques"
  description: "When developing a high frequency environment, every transaction is a race against the clock and against other players in the market. Therefore, your critical flow can never be “fast enough” as long as someone else may be faster. In this lecture I will cover some of the techniques qSpark’s trading infrastructure uses to survive in the HFT jungle, and will discuss in detail one of our main techniques: using dummy operations to warm up the instruction cache for critical operations while avoiding branch mis-predictions."
  subtype: talk
  speakers: [28]
  language: en
-
  id: 029
  title: "Building efficient I/O intensive applications with Seastar"
  description: "<p>Seastar is a C++14/C++17 application framework focused on I/O and multicore. It uses all C++ features we could lay our hands on, and plans to use coroutines and modules as soon as they are available.</p>
                <p>The talk will cover the theory behind Seastar, explain how it is used in practice, and cover the advanced C++ techniques we used.</p>"
  subtype: talk
  speakers: [29]
  language: en
-
  id: 031
  title: "Standard Library Design"
  description: "The C++ standard library is one of the most widely used components in contemporary software. It is also one of the most opinionated. What makes it so successful? Why is it shaped the way that it is? In this talk, we'll delve into the core principles that underpin the C++ standard library and discover the rationale behind its design."
  subtype: talk
  speakers: [31]
  language: en
-
  id: 032
  title: "Compile Time Regular Expressions"
  description: "<p>I will present a library that utilizes a feature of C++20 to build regular expressions from compile-time strings. This is a novel approach that doesn't have ordinary disadvantages of other regular expression implementations like having to use a linked library or a run-time cost of parsing and interpreting an internal finite machine. </p>
                <p>You will see implementation details of the library and problems I have run into during its writing. In the last part of the talk, I will compare other implementations of regular expression engines and show compiled code in Compiler Explorer.</p>"
  subtype: talk
  speakers: [32]
  language: en
-
  id: 033
  title: "C++: λ Demystified"
  description: "<p>C++11 lambdas brought us lambdas. They open a lot of new possibilities. Frequently asked questions are:</p>
                <ul>
                  <li>How are they implemented?</li>
                  <li>How do they work?</li>
                  <li>How can it affect my daily programming?</li>
                  <li>Do they generate a lot of code?</li>
                  <li>What can I do with them?</li>
                  <li>Where can I use them?</li>
                </ul>
                <p>In this talk I will answer these questions. With the support of C++ Insights (<a href='https://cppinsights.io'>https://cppinsights.io</a>) we will peak behind the scenes to answer questions about how they are implemented. We will also see how the compiler generated code changes, if we change the lambda itself. This is often interesting for development in constrained applications like the embedded domain.</p>
                <p>Next I will show you application areas of lambdas to illustrate where they can be helpful. For example, how they can help you to write less and with that more unique code.</p>
                <p>After the talk, you will have a solid understanding of lambdas in C++. Together with some ideas when and where to use them.</p>"
  subtype: talk
  speakers: [33]
  language: en
-
  id: 034
  title: "Initialisation in modern C++"
  description: "<p>Initialisation semantics is widely regarded as one of the most difficult aspects of the C++ language. We have many different kinds of initialisation and many different syntaxes for it, and they interact in complex and often surprising ways. C++11 introduced the concept of 'uniform initialisation'. But instead of unifying, this feature introduced even more complex rules, which were subsequently amended in C++14, C++17, and will be changed again for C++20.</p>
                <p>In this talk, I'll first summarise the history of initialisation in C++. I'll then give a systematic overview over the current initialisation rules and common pitfalls and surprises. There will be some practical coding guidelines to help using those rules effectively. Finally, we will discuss recent proposals towards making initialisation semantics in C++20 simpler and more user-friendly.</p>"
  subtype: talk
  speakers: [34]
  language: en
-
  id: 035
  title: "C++ ecosystem: For better, for worse"
  description: "<p>This is not really a practical talk with which you could learn a new language feature or two, but it is more of a high-level overview of the C++ development ecosystem. Still, it should be useful for C++ developers of any level or specialization. Those who are just getting started with the language should take away an understanding of the whole ecosystem and some direction to help find their own path, while C++ committee members and language influencers will gain deeper insight into the needs of the C++ community.</p>
                <p>First, I plan to overview the current state of C++ development, using information gathered from several independent sources. These include surveys conducted by JetBrains through both internal and external channels, one of which attracted more than 4,000 C++ developer respondents; a survey run by the C++ Foundation; and a few other third-party research studies.</p>
                <p>Next, we’ll explore which language features, tools, and techniques are used across different areas of development, to help us identify the key evolution paths in the ecosystem. In addition, I’ll briefly overview some typical areas of application of C++ to identify the most important needs and requests of C++ developers.</p>
                <p>Last, we’ll discuss how the current language evolution addresses these needs. I will also focus on how the tooling can collaborate with the language to help drive the adoption of new features.</p>"
  subtype: talk
  speakers: [35]
  language: en
-
  id: 036
  title: "The Dawn Of A New Error"
  description: "<p>As a community we've tried many different ways to express, propagate and handle error conditions in our code over the years. Each seem to have different trade-offs, with none being perfect in all cases.</p>
                <p>In C++ we adopted exceptions as the primary mechanism early on, and the standard library uses them extensively.</p>
                <p>Yet many - 52% according to last year's Standard C++ Foundation survey - ban exceptions in all, or part, of their codebases!</p>
                <p>Recently there has been a lot of interest in using ADTs (Algebraic Data Types) such as `std::optional`, or the proposed `std::expected`, for error-handling. There are definitely advantages here, but we're still not quite there yet. Can we do better?</p>
                <p>This presentation summarises the material from my earlier talk, 'Option(al) Is Not a Failure', where I survey existing error-handling approaches and score them against each other, leading up to the new proposal, p0709r1, 'Zero-overhead deterministic exceptions'. We then dig into this proposal in more depth and look at the implications, considering also the supporting proposals, p1028 (std::error) and p1029 ([[move relocates]]) and others. We'll also look at experiences with similar mechanisms in other languages, notably Swift, to get an idea of how it might work out in practice.</p>
                <p>In the end we should have a solid idea of which error handling strategy to use when, what's coming next, and how to approach code now that will play nicely in that possible future.</p>"
  subtype: talk
  speakers: [10]
  language: en
-
  id: 037
  title: "Understanding Lvalues and Rvalues"
  description: "You've probably heard the terms lvalue and rvalue, if only because they occasionally appear in compiler error messages. However, if you have only a vague understanding of what they mean, you're not alone. Lvalues and rvalues aren't actually language features, but rather semantic properties of expressions and sub-expressions. Understanding lvalues and rvalues provides valuable insights into the behavior of built-in operators, the code generated to execute those operators, and the meaning of some otherwise cryptic compiler error messages. Also, understanding lvalues and rvalues is essential background for working effectively with reference types and overloaded operators. This session covers what you need to know about lvalues and rvalues in C++."
  subtype: talk
  speakers: [13]
  language: en
-
  id: 099
  title: "Welcome to Core C++ 2019!"
  subtype: keynote
  service: true
-
  id: 101
  title: "Break"
  service: true
-
  id: 102
  title: "Lunch"
  service: true
-
  id: 103
  title: "Lightning Talks"
  service: true
-
  id: 104
  title: "Updates"
  service: true
-
  id: 105
  title: "Closing Remarks"
  service: true
